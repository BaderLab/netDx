% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smooMutationPropagation.R
\name{smoothMutations_LabelProp}
\alias{smoothMutations_LabelProp}
\title{This function applies the random walk with restart propagation algorithm to a
matrix of patients profiles}
\usage{
smoothMutations_LabelProp(mat, net, cl, no_cores)
}
\arguments{
\item{mat}{(data.frame) sparse matrix of patient profiles. Rownames
are unique genes. Colnames are unique patients. A cell is a numeric value.}

\item{net}{(data.frame) adjancy matrix format of a network}

\item{cl}{(SOCKcluster) cluster object created with makeCluster function 
from parallel}

\item{no_cores}{(numeric) number of cores used to create the cluster object}
}
\value{
(data.frame) continuous matrix of patient profiles in which each gene
  has the final propagation score
}
\description{
This function applies the random walk with restart propagation algorithm to a
matrix of patients profiles
}
\details{
A network is an undirected graph G defined by a set of nodes
  corresponding to genes, and edges connecting nodes with an experimental
  evidence of interaction. A priori nodes are genes for which an information
  is known. A novel node is a candidate for being associated to the nodes
  above based on their information. A node prediction task leads to detect
  novel nodes and propagation techniques are largely applied for the purpose.
  Network-based propagation algorithms for node prediction transfer the
  information from a priori nodes to any other node in a network. Each node
  gets an imputation value which assesses how much information got. The
  prediction is based on the guilty-by-association principle. A node with a
  high imputation value has a high probability to be associated to a priori
  nodes. E.g. in a house where room A has one heater, if room B is the second
  hottest room it means that B is close to A and that there is a high
  probability that they share a door or wall. These algorithms exploit the
  global topology of the network. However, when they are applied to detect if
  unknown nodes are functionally associated to known ones, they may suffer of
  a drawback depending by the context. In biology, two functionally related
  fragments interact physically (direct interaction) or interact indirectly
  thanks to one or very few mediators. Therefore, exploring too far
  similarities between nodes can introduce noise in the prediction. We apply
  a random walk with restart propagation algorithm which resolution is set to
  0.2 for giving high values only to the close neighbours of the a priori
  nodes.
}
\examples{
  set.seed(8)
  numCores <- 8L
  library("netDx")
  require("MultiAssayExperiment")
  outDir <- "/output"
  out_plot_perf <- paste(outDir,"plot_performances.png",sep=getFileSep())
  out_features_table <- paste(outDir,"OV_features_table.csv",sep=getFileSep())
  out_res_rda <- paste(outDir,"OV_results.rda",sep=getFileSep())
  genoFile <- paste(path.package("netDx"),"extdata","OV_mutSmooth_geno.txt",
  sep=getFileSep())
  geno <- read.delim(genoFile,sep="\t",header=TRUE,as.is=TRUE)
  phenoFile <- paste(path.package("netDx"),"extdata","OV_mutSmooth_pheno.txt",
  sep=getFileSep())
  pheno <- read.delim(phenoFile,sep="\t",header=TRUE,as.is=TRUE)
  colnames(geno) <- gsub("-",".",colnames(geno))
  pheno$ID <- gsub("-",".",pheno$ID)
  rownames(pheno) <- pheno$ID
  netFile <- paste(path.package("netDx"),"extdata","CancerNets.txt",
  sep=getFileSep())
  cancerNets <- read.delim(netFile,sep="\t",header=T,as.is=T)
  message("* Excluding genes not present in interaction nets")
  noData <- setdiff(rownames(geno),rownames(cancerNets))
  if (length(noData)>0) {
  	message(paste(length(noData), 
  		" genes not present in cancer nets; excluding",sep=""))
  	geno <- geno[-which(rownames(geno) \%in\% noData),]
  }
  
  message("* Running label prop")
  require(doParallel)
  cl <- makeCluster(numCores)
  registerDoParallel(cl)
  prop_net <- smoothMutations_LabelProp(geno,cancerNets,cl,no_cores=numCores)
  stopCluster(cl)
}
