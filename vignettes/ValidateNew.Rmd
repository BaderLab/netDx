---
title: "Validate trained model on an independent dataset"
author: "Shraddha Pai"
package: netDx
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
    %\VignetteIndexEntry{04. Validate model with selected features on an independent dataset}.
    %\VignetteEngine{knitr::knitr}
    %\VignetteEncoding{UTF-8}
---

# TL;DR
This code block is not evaluated. Need a breakdown? Look at the following sections.
```{r,eval=FALSE}
```

# Introduction

Validating a trained model on an independent new dataset is important to ensure that the model generalizes on new samples and has real-world value. In netDx, we first use `buildPredictor()` to train models, wherein we score features based on their predictive value for various patient labels. In this example, we use the `predict()` function to classify samples held out from the original training. 

We're going to reuse the application from earlier vignettes, seeking to classify breast tumour profiles as either being of "Luminal A" subtype or other. 

# Split Data into Training and Hold-Out Set

```{r,eval=TRUE}
suppressWarnings(suppressMessages(require(netDx)))
suppressMessages(require(curatedTCGAData))
suppressMessages(require(plotrix))
```

We start by formatting the input data.
```{r,eval=TRUE}
brca <- suppressMessages(curatedTCGAData("BRCA",c("mRNAArray"),FALSE, version="1.1.38"))
staget <- sub("[abcd]","",sub("t","",colData(brca)$pathology_T_stage))
staget <- suppressWarnings(as.integer(staget))
colData(brca)$STAGE <- staget

pam50 <- colData(brca)$PAM50.mRNA
pam50[which(!pam50 %in% "Luminal A")] <- "notLumA"
pam50[which(pam50 %in% "Luminal A")] <- "LumA"
colData(brca)$pam_mod <- pam50

tmp <- colData(brca)$PAM50.mRNA
idx <- union(which(tmp %in% c("Normal-like","Luminal B","HER2-enriched")),
             		which(is.na(staget)))
pID <- colData(brca)$patientID
tokeep <- setdiff(pID, pID[idx])
brca <- brca[,tokeep,]

# remove duplicate assays mapped to the same sample
smp <- sampleMap(brca)
samps <- smp[which(smp$assay=="BRCA_mRNAArray-20160128"),]
notdup <- samps[which(!duplicated(samps$primary)),"colname"]
brca[[1]] <- suppressMessages(brca[[1]][,notdup])

message("* Holding out 10 samples per class for validation")

pam50 <- colData(brca)$pam_mod
pheno <- colData(brca)
```

Set 20 samples aside for independent validation. In practice, this sample size may be larger (e.g. 30% held-out, or independent dataset).

```{r,eval=TRUE}
set.seed(123) # make reproducible
idx_holdout <- c(
  sample(which(pam50 == "LumA"),10,F),
  sample(which(pam50 == "notLumA"),10,F)
	)
holdout <- brca[,rownames(pheno)[idx_holdout]]
colData(holdout)$ID <- as.character(colData(holdout)$patientID)
brca <- brca[,rownames(pheno)[setdiff(1:length(pam50),idx_holdout)]]

pID <- as.character(colData(brca)$patientID)
colData(brca)$ID <- pID
colData(brca)$STATUS <- colData(brca)$pam_mod
```

# Train model on training Samples
The rest of the process for data setup and running the model is identical to that shown in previous vignettes. 

Create feature groupings:
```{r,eval=TRUE}
# genes in mRNA data are grouped by pathways
pathList <- readPathways(fetchPathwayDefinitions("January",2018))

groupList <- list()
groupList[["BRCA_mRNAArray-20160128"]] <- pathList[1:3]

# clinical data is not grouped; each variable is its own feature
groupList[["clinical"]] <- list(
      age="patient.age_at_initial_pathologic_diagnosis",
	   stage="STAGE"
)
```

Define the function to convert features into patient similarity networks:
```{r,eval=TRUE}
makeNets <- function(dataList, groupList, netDir, ...) {
  netList <- c() # initialize before is.null() check
  # make RNA nets (NOTE: the check for is.null() is important!)
  # (Pearson correlation)
  if (!is.null(groupList[["BRCA_mRNAArray-20160128"]])) {
    netList <- makePSN_NamedMatrix(dataList[["BRCA_mRNAArray-20160128"]],
        rownames(dataList[["BRCA_mRNAArray-20160128"]]),
          groupList[["BRCA_mRNAArray-20160128"]],
        netDir, verbose = FALSE,
          writeProfiles = TRUE, ...)
  }

  # make clinical nets (normalized difference)
  netList2 <- c()
  if (!is.null(groupList[["clinical"]])) {
    netList2 <- makePSN_NamedMatrix(dataList$clinical,
    rownames(dataList$clinical),
    groupList[["clinical"]], netDir,
    simMetric = "custom", customFunc = normDiff, # custom function
    writeProfiles = FALSE,
    sparsify = TRUE, verbose = TRUE, ...)
  }
  netList <- c(unlist(netList), unlist(netList2))
  return(netList)
}
```

Train the model:
```{r,eval=TRUE}
set.seed(42) # make results reproducible
outDir <- paste(tempdir(),randAlphanumString(),
	"pred_output",sep=getFileSep())
# set keepAllData=TRUE to not delete at the end of the predictor run.
# This can be useful for debugging.
numSplits <- 2L
out <- buildPredictor(
      dataList=brca,groupList=groupList,
      makeNetFunc=makeNets,
      outDir=outDir, ## netDx requires absolute path
      numSplits=numSplits,
      featScoreMax=2L,
      featSelCutoff=1L,
      numCores=1L,debugMode=FALSE,
      logging="none")
```

Compile feature scores:
```{r,eval=TRUE}
 for (k in 1:numSplits) { 
 	# feature scores
 	for (cur in unique(st)) {
 	   tmp <- out[[sprintf("Split%i",k)]][["featureScores"]][[cur]]
 	   colnames(tmp) <- c("PATHWAY_NAME","SCORE")
 	   featScores[[cur]][[sprintf("Split%i",k)]] <- tmp
 	}
 }
 # compile scores across runs
 featScores2 <- lapply(featScores, getNetConsensus)
```

Identify consistently high-scoring features for each class. In this toy example, we pick any feature that scored a minimum of 1 (`fsCutoff`) in one or more split (`fsPctPass`).
```{r,eval=TRUE}
 featSelNet <- lapply(featScores2, function(x) {
     callFeatSel(x, fsCutoff=1, fsPctPass=0)
})
```

# Validate on independent samples
```{r,eval=TRUE}
names(groupList[["BRCA_mRNAArray-20160128"]]) <- gsub(",", ".",
  names(groupList[["BRCA_mRNAArray-20160128"]]))
predModel <- predict(brca, holdout, groupList, featSelNet, makeNets,
  outDir, verbose = FALSE)
```

# Plot results of validation

```{r,eval=TRUE}
pdf(sprintf("perf.pdf"))
plotPerf_multi(list(perf$rocCurve),
  plotTitle = sprintf("BRCA Validation: %i samples", nrow(colData(holdout))))
plotPerf_multi(list(perf$prCurve), plotType = "PR",
  plotTitle = sprintf("BRCA Validation: %i samples", nrow(colData(holdout))))
dev.off()

pdf("colormat.pdf")
tbl <- as.matrix(table(out[,c("STATUS","PRED_CLASS")]))
color2D.matplot((tbl/nrow(out))*100,show.values=TRUE,axes=FALSE,
	xlab="Predicted label", ylab="Actual label",par(las=1))
axis(1,at=seq_len(ncol(tbl))-0.5,labels=colnames(tbl))
axis(2,at=seq_len(nrow(tbl))-0.5,labels=rownames(tbl))
dev.off()
```

