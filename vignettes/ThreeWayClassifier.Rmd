---
title: "Building N-way classifier (N>2) from clinical and 'omic data"
author: "Shraddha Pai"
package: netDx
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
    %\VignetteIndexEntry{02. Build N-way classifier (N>2)}
    %\VignetteEngine{knitr::knitr}
    %\VignetteEncoding{UTF-8}
---

# TL;DR -- TBA once code is finalized
This code block is not evaluated. Need a breakdown? Look at the following sections.
```{r,eval=FALSE}
```

# Introduction

This example is nearly identical to the example to build a binary classifier. 
Here we will use the same data as used in that example, but to build a three-way
patient classifier. To recap, the goal is breast tumour classification using clinical data and gene expression data. We will create pathway-level features for gene expression and use variable-level features for clinical data.

# Setup

```{r,eval=TRUE}
suppressWarnings(suppressMessages(require(netDx)))
```

# Data 

In this example, we use curated data from The Cancer Genome Atlas, through the BioConductor `curatedTCGAData` package. The goal is to classify a breast tumour as a 'Luminal A', 'Luminal B', or 'Basal' type tumour. The predictor will integrate clinical variables selected by the user, along with gene expression data.

Here we load the required packages and download clinical and gene expression data.
```{r,eval=TRUE}
suppressMessages(library(curatedTCGAData))
suppressMessages(library(MultiAssayExperiment))
```

This is the data we will use:
```{r,eval=TRUE}
curatedTCGAData(diseaseCode="BRCA", assays="*",dry.run=TRUE)
```
Let's fetch and store the data locally:
```{r,eval=TRUE}
brca <- curatedTCGAData("BRCA",c("mRNAArray","RPPA*","Methylation_methyl27*"),
```

This next code block prepares the TCGA data. In practice you would do this once, and save the data before running netDx, but we run it here to see an end-to-end example. 

```{r,eval=TRUE}
# prepare clinical variable - stage
staget <- sub("[abcd]","",sub("t","",colData(brca)$pathology_T_stage))
staget <- as.integer(staget)
colData(brca)$STAGE <- staget

# exclude normal, HER2 (small num samples)
pam50 <- colData(brca)$PAM50.mRNA
idx <- union(which(pam50 %in% c("Normal-like","HER2-enriched")), 
	which(is.na(st2)))
idx <- union(idx, which(is.na(pam50)))
pID <- colData(brca)$patientID
tokeep <- setdiff(pID, pID[idx])
brca <- brca[,tokeep,]

pam50 <- colData(brca)$PAM50.mRNA
colData(brca)$pam_mod <- pam50

# remove duplicate names
smp <- sampleMap(brca)
message("removing samples")
for (nm in names(brca)) {
	message(nm)
	samps <- smp[which(smp$assay==nm),]
	notdup <- samps[which(!duplicated(samps$primary)),"colname"]
	brca[[nm]] <- brca[[nm]][,notdup]
}
```

The important thing is to create `ID` and `STATUS` columns in the sample metadata slot. netDx uses these to get the patient identifiers and labels, respectively.

```{r,eval=TRUE}
pID <- colData(brca)$patientID
colData(brca)$ID <- pID
colData(brca)$STATUS <- gsub(" ","_",colData(brca)$pam_mod)
```

# Rules to create features (patient similarity networks)

```{r,eval=TRUE}
groupList <- list()

# genes in mRNA data are grouped by pathways
pathList <- readPathways(fetchPathwayDefinitions("January",2018))
groupList[["BRCA_mRNAArray-20160128"]] <- pathList[1:3]
# clinical data is not grouped; each variable is its own feature
groupList[["clinical"]] <- list(
      age="patient.age_at_initial_pathologic_diagnosis",
	   stage="STAGE"
)
# for methylation generate one feature containing all probes
# same for proteomics data
tmp <- list(rownames(experiments(brca)[[2]]));names(tmp) <- names(brca)[2]
groupList[[names(brca)[2]]] <- tmp
tmp <- list(rownames(experiments(brca)[[3]]));names(tmp) <- names(brca)[3]
groupList[[names(brca)[3]]] <- tmp
```

## Define patient similarity for each network

This is identical to the function used for binary classification.

```{r,eval=TRUE}
makeNets <- function(dataList, groupList, netDir,...) {
	netList <- c() # initialize before is.null() check
	# correlation-based similarity for mRNA, RPPA and methylation data
	# (Pearson correlation)
	for (nm in names(groupList)) {
		if (!is.null(groupList[[nm]])) {# (NOTE: the check for is.null() is important!)
		netList <- makePSN_NamedMatrix(dataList[[nm]],rownames(dataList[[nm]]),
				   	groupList[[nm]],netDir,verbose=FALSE,writeProfiles=TRUE,...) 
		}
	}
	
	# make clinical nets (normalized difference)
	netList2 <- c()
	if (!is.null(groupList[["clinical"]])) {
	netList2 <- makePSN_NamedMatrix(dataList$clinical, 
		rownames(dataList$clinical),
		groupList[["clinical"]],netDir,
		simMetric="custom",customFunc=normDiff, # custom function
		writeProfiles=FALSE,
		sparsify=TRUE,verbose=TRUE,...)
	}
	netList <- c(unlist(netList),unlist(netList2))
	return(netList)
}

```

# Build predictor

This call is also identical to that used for the binary classifier. 
 
```{r,eval=TRUE}
set.seed(42) # make results reproducible
outDir <- sprintf("%s/pred_output",tempdir()) # location for intermediate work
# set keepAllData to TRUE to not delete at the end of the predictor run.
# This can be useful for debugging.
numSplits <- 2L

out <- buildPredictor(dataList=brca,groupList=groupList,
  makeNetFunc=makeNets,outDir=outDir,
  numSplits=numSplits, featScoreMax=2L, featSelCutoff=1L,
	numCores=1L)
```

# Examine output
The results are stored in the list object returned by the `buildPredictor()` call.
This list contains:

* `inputNets`: all input networks that the model started with. 
* `Split<i>`: a list with results for each train-test split
  * `predictions`: real and predicted labels for test patients
  * `accuracy`: percent accuracy of predictions
  * `featureScores`: feature scores for each label (list with `g` entries, where `g` is number of patient labels). Each entry contains the feature selection scores for the corresponding label.
  * `featureSelected`: vector of features that pass feature selection. List of length `g`, with one entry per label.

```{r,eval=TRUE}
summary(out)
summary(out$Split1)
```

Save results to a file for downstream analysis:
```{r,eval=TRUE}
save(out,file=sprintf("%s/results.rda",outDir))
```

Write prediction results to text files. But also compute accuracy for three-way
classification.

```{r,eval=TRUE}
# Average accuracy
acc <- matrix(NA,ncol=length(st),nrow=numSplits) 
colnames(acc) <- st 

numSplits <- 2
st <- unique(colData(brca)$STATUS) # to get similarity scores for each class
for (k in 1:numSplits) { 
	pred <- out[[sprintf("Split%i",k)]][["predictions"]];
	oF <- sprintf("%s/Split%i_predictionResults.txt",outDir,k)
	tmp <- pred[,c("ID","STATUS","TT_STATUS","PRED_CLASS",sprintf("%s_SCORE",st))]
	write.table(tmp,file=oF,sep="\t",col=TRUE,row=FALSE,quote=FALSE)
}

print(round(acc,2))

print("Confusion matrix")
res <- out$Split1$predictions
print(table(res[,c("STATUS","PRED_CLASS")]))
```

# sessionInfo

```{r,eval=TRUE}
sessionInfo()
```
