#' Using GMT files, generate enrichment maps and apply Auto annotate app to them

#' @param gmtFile (char) file path to GMT file (generated by writeEMap_file()).
#' NOTE: This needs to be the absolute path name
#' @param nodeAttrFile (list) file path to nodeAttr.txt file (generated by
#' writeEMap_file())
#' @param netName (char) name for network in Cytoscape. Using the patient
#' class name is a good idea. (e.g. SURVIVE_YES and SURVIVE_NO).
#' @param outDir (char) path to directory where file should be stored.
#' @param minScore (int) minimum score of node to show
#' @param maxScore (int) maximum score of node to show
#' @param colorScheme (char) colour scheme for nodes. "cont_heatmap" 
#' sets a discrete map ranging from yellow to red for increasing scores. 
#' "netDx_ms" is the colour scheme used in the netDx methods paper.
#' This map is (<=6: white; 7-9: orange; 10: red)
#' @param cytoscapeBaseURL (char) URL for CyREST connection to the active
#' Cytoscape session. Only change this if you know what you're doing.
#' @param verbose (logical) print messages
#' @examples
#' #refer to writeEMapInput_many.R for working writeEMapInput_many() example
#' EMap_input <- writeEMapInput_many(featScores,pathwayList,
#'      netInfo,outDir=outDir)
#' outDir <- paste(getwd(),"plots",sep="/")
#' if (!file.exists(outDir)) dir.create(outDir)
#' gmtFile <- EMap_input[[1]][1]
#' nodeAttrFile <- EMap_input[[1]][2]
#' plotEmap(gmtFile = gmtFile, nodeAttrFile = nodeAttrFile, netName="HighRisk",
#'	outDir=outDir)
#' @import r2cytoscape
#' @import httr
#' @importFrom RJSONIO fromJSON
#' @export
plotEmap <- function(gmtFile, nodeAttrFile, netName="generic",
	outDir,minScore=1,maxScore=10,colorScheme="cont_heatmap",
	cytoscapeBaseURL="http://localhost:1234/v1",
	verbose=FALSE){

	validColSchemes <- c("cont_heatmap","netDx_ms")
	if (!colorScheme %in% validColSchemes) {
		stop(sprintf("colorScheme should be one of { %s }\n",
			paste(validColSchemes,collapse=",")))
	}

	base.url <- cytoscapeBaseURL
  version.url = paste(base.url, "version", sep="/")
  cytoscape.open = TRUE

  tryCatch(expr = { GET(version.url)},
           error = function(e) { return (cytoscape.open = FALSE)},
           finally =function(r){ return(cytoscape.open = TRUE)})

  if(!cytoscape.open){
    #try and launch cytoscape
   print("Cytoscape is not open.  Please launch cytoscape.")
  } else{
    cytoscape.version =  GET(version.url)
    cy.version = RJSONIO::fromJSON(rawToChar(cytoscape.version$content))
    print(cy.version)
  }

  #######################################
  #create EM using given parameters
  #######################################
  #enrichment map command will return the suid of newly created network.
  #Run comman directly in R
  enrichmentmap.url <- paste(base.url,
			"commands","enrichmentmap","build", sep="/")
  em_params <- list(analysisType = "generic",
			gmtFile = gmtFile,pvalue=1, qvalue=1,
			similaritycutoff=0.05,coeffecients="JACCARD") # typo in current EM
  response <- GET(url=enrichmentmap.url, query=em_params)

  response <- renameNetwork(netName, network = character(0))

  #annotate the network using AutoAnnotate app
	cat("* Applying AutoAnnotate\n")
  aa_command <- paste("autoannotate annotate-clusterBoosted clusterAlgorithm=MCL maxWords=3
    network=",netName, sep=" ")
  response <- commandRun(aa_command)

	cat("* Importing node attributes\n")
  table_command <- sprintf("table import file file=%s keyColumnIndex=1
    firstRowAsColumnNames=true startLoadRow=1 TargetNetworkList=%s WhereImportTable=To%%20selected%%20networks%%20only",
		nodeAttrFile,netName)
  response <- commandRun(table_command)

	#apply style
	cat("* Creating or applying style\n")
  all_unique_scores_int <- sort(unique(read.delim(nodeAttrFile)[,2]))
  all_unique_scores <- unlist(lapply(all_unique_scores_int, toString))
  styleName <- "EMapStyle"
  res	<- httr::GET(sprintf("%s/styles",base.url))
  curStyles <- gsub("\\\"","",rawToChar(res$content))
  curStyles <- unlist(strsplit(curStyles,","))

  if (any(grep("EMapStyle",curStyles))) {
  	if (verbose) cat("style exists not creating\n")
  } else {
  	if (verbose) cat("Creating style\n")

		# define colourmap
		scoreVals <- minScore:maxScore
		style_cols <- ""
		if (colorScheme=="cont_heatmap") {
			colfunc <- colorRampPalette(c("yellow", "red"))
			gradient_cols <- colfunc(length(scoreVals))
			style_cols <- colfunc(length(scoreVals)) #gradient_cols[scoreVals[1:length(scoreVals)]]
		} else if (colorScheme=="netDx_ms") {
			if (minScore < 1 | maxScore > 10) 
				stop("The 'netDx_ms' colorScheme requires minScore and maxScore to be between 1 and 10.")
			style_cols <- rep("white", length(scoreVals))
			style_cols[which(scoreVals>=7)] <- "orange"
			style_cols[which(scoreVals==10)] <- "red"
	} 

  	style_mapping <- mapVisualProperty(
			visual.prop='node fill color',
			table.column='maxScore',
			mapping.type='d',
			as.character(scoreVals),style_cols,
			network=netName)
 		defaults <- list("NODE_SHAPE"="ellipse",
  			"NODE_SIZE"=30,
  			"EDGE_TRANSPARENCY"=200,
  			"NODE_TRANSPARENCY"=255,
				"EDGE_STROKE_UNSELECTED_PAINT"="#999999")
 		sty <- r2cytoscape::createStyle(styleName,
  		defaults=defaults,
  		mappings=list(style_mapping))
 }

  network.suid <- getNetworkSuid()
  # apply style
  apply.style.url <- sprintf("%s/apply/styles/%s/%s",
  	base.url,styleName,network.suid)
  response <- httr::GET(apply.style.url)

	# final layout and redraw
	cat("* Final cleanup\n")
	layout_command <- "layout attributes-layout NodeAttribute=__mclCLuster"
    response <- commandRun(layout_command)

    redraw_command <- sprintf("autoannotate redraw network=%s",
			network.suid)
    response <- commandRun(redraw_command)

	# fit content
	fitCommand <- sprintf("%s/commands/view/fit content",base.url)
	response	<- httr::GET(fitCommand)

	# export to png
	pngFile 		<- sprintf("%s/EnrichmentMap_%s.png",outDir,netName)
	if (file.exists(pngFile)) unlink(pngFile) # avoid the "overwrite file?"
																						# dialog
	exportURL <- sprintf("%s/commands/view/export?OutputFile=%s",
			base.url,pngFile)
print(exportURL)
	response	<- httr::GET(exportURL)

	return(pngFile)
}
