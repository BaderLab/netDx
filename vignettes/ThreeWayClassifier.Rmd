---
title: "Building N-way classifier (N>2) from clinical and 'omic data"
author: "Shraddha Pai"
package: netDx
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
    %\VignetteIndexEntry{02. Build N-way classifier (N>2)}
    %\VignetteEngine{knitr::knitr}
    %\VignetteEncoding{UTF-8}
---

# TL;DR
This code block is not evaluated. Need a breakdown? Look at the following sections.
```{r,eval=FALSE}
suppressWarnings(suppressMessages(require(netDx)))
suppressMessages(library(curatedTCGAData))
suppressMessages(library(MultiAssayExperiment))

brca <- curatedTCGAData("BRCA",c("mRNAArray"),FALSE)

staget <- colData(brca)$pathology_T_stage
st2 <- rep(NA,length(staget))
st2[which(staget %in% c("t1","t1a","t1b","t1c"))] <- 1
st2[which(staget %in% c("t2","t2a","t2b"))] <- 2
st2[which(staget %in% c("t3","t3a"))] <- 3
st2[which(staget %in% c("t4","t4b","t4d"))] <- 4
colData(brca)$STAGE <- st2

# exclude normal, HER2 (low sample count)
pam50 <- colData(brca)$PAM50.mRNA
idx <- union(which(pam50 %in% c("Normal-like","HER2-enriched")), 
	which(is.na(st2)))
idx <- union(idx, which(is.na(pam50)))
pID <- colData(brca)$patientID
tokeep <- setdiff(pID, pID[idx])
brca <- brca[,tokeep,]

pam50 <- colData(brca)$PAM50.mRNA
colData(brca)$pam_mod <- pam50

smp <- sampleMap(brca)
samps <- smp[which(smp$assay=="BRCA_mRNAArray-20160128"),]
notdup <- samps[which(!duplicated(samps$primary)),"colname"]
brca[[1]] <- brca[[1]][,notdup]

pID <- colData(brca)$patientID
colData(brca)$ID <- pID
colData(brca)$STATUS <- gsub(" ",".",colData(brca)$pam_mod)

# group variables into features
groupList <- list()
# genes in mRNA data are grouped by pathways
pathList <- readPathways(getExamplePathways())
groupList[["BRCA_mRNAArray-20160128"]] <- pathList[1:3]
# clinical data is not grouped; each variable is its own feature
groupList[["clinical"]] <- list(
      age="patient.age_at_initial_pathologic_diagnosis",
	   stage="STAGE"
)

# custom function to build patient similarity networks
makeNets <- function(dataList, groupList, netDir,...) {
	netList <- c() # initialize before is.null() check
	# make RNA nets (NOTE: the check for is.null() is important!)
	# (Pearson correlation)
	if (!is.null(groupList[["BRCA_mRNAArray-20160128"]])) { 
	netList <- makePSN_NamedMatrix(dataList[["BRCA_mRNAArray-20160128"]],
				rownames(dataList[["BRCA_mRNAArray-20160128"]]),
			   	groupList[["BRCA_mRNAArray-20160128"]],
				netDir,verbose=FALSE, 
			  	writeProfiles=TRUE,...) 
	}
	
	# make clinical nets (normalized difference)
	netList2 <- c()
	if (!is.null(groupList[["clinical"]])) {
	netList2 <- makePSN_NamedMatrix(dataList$clinical, 
		rownames(dataList$clinical),
		groupList[["clinical"]],netDir,
		simMetric="custom",customFunc=normDiff, # custom function
		writeProfiles=FALSE,
		sparsify=TRUE,verbose=TRUE,...)
	}
	netList <- c(unlist(netList),unlist(netList2))
	return(netList)
}


set.seed(42) # make results reproducible
outDir <- sprintf("%s/pred_output",tempdir()) # location for intermediate work
# set keepAllData to TRUE to not delete at the end of the predictor run.
# This can be useful for debugging.
numSplits <- 2

out <- buildPredictor(dataList=brca,groupList=groupList,
  makeNetFunc=makeNets,outDir=outDir,
  numSplits=numSplits,featScoreMax=2L, featSelCutoff=1L,
  keepAllData=2,
	numCores=1L)

save(out,file=sprintf("%s/results.rda",outDir))
st <- unique(colData(brca)$STATUS) # to get similarity scores for each class

# Compute accuracy in each split
acc <- matrix(NA,ncol=length(st),nrow=numSplits) 
colnames(acc) <- st 

for (k in 1:numSplits) { 
	pred <- out[[sprintf("Split%i",k)]][["predictions"]];
	oF <- sprintf("%s/Split%i_predictionResults.txt",outDir,k)
	tmp <- pred[,c("ID","STATUS","TT_STATUS","PRED_CLASS",
		sprintf("%s_SCORE",st))]
	write.table(tmp,file=oF,sep="\t",col=TRUE,row=FALSE,quote=FALSE)

	# label-specific accuracy
	ctr <- 1
	for (m in st) { 
		tmp2 <- subset(tmp, STATUS==m)
		acc[k,ctr] <- (sum(tmp2$STATUS==tmp2$PRED_CLASS)/nrow(tmp2))*100
		ctr <- ctr+1
	}
}

print("Confusion matrix")
res <- out$Split1$predictions
print(table(res[,c("STATUS","PRED_CLASS")]))
```

# Introduction

This example is nearly identical to the example to build a binary classifier. 
Here we will use the same data as used in that example, but to build a three-way
patient classifier. To recap, the goal is breast tumour classification using clinical data and gene expression data. We will create pathway-level features for gene expression and use variable-level features for clinical data.

# Setup

```{r}
suppressWarnings(suppressMessages(require(netDx)))
```

# Data 

In this example, we use curated data from The Cancer Genome Atlas, through the BioConductor `curatedTCGAData` package. The goal is to classify a breast tumour as a 'Luminal A', 'Luminal B', or 'Basal' type tumour. The predictor will integrate clinical variables selected by the user, along with gene expression data.

Here we load the required packages and download clinical and gene expression data.
```{r,eval=FALSE}
suppressMessages(library(curatedTCGAData))
suppressMessages(library(MultiAssayExperiment))
```

This is the data we will use:
```{r}
curatedTCGAData(diseaseCode="BRCA", assays="*",dru.run=TRUE)
```
Let's fetch and store the data locally:
```{r}
brca <- curatedTCGAData("BRCA",c("mRNAArray"),FALSE)
```

This next code block prepares the TCGA data. In practice you would do this once, and save the data before running netDx, but we run it here to see an end-to-end example. 

```{r,eval=FALSE}
staget <- colData(brca)$pathology_T_stage
st2 <- rep(NA,length(staget))
st2[which(staget %in% c("t1","t1a","t1b","t1c"))] <- 1
st2[which(staget %in% c("t2","t2a","t2b"))] <- 2
st2[which(staget %in% c("t3","t3a"))] <- 3
st2[which(staget %in% c("t4","t4b","t4d"))] <- 4
colData(brca)$STAGE <- st2

# exclude normal, HER2 (small num samples)
pam50 <- colData(brca)$PAM50.mRNA
idx <- union(which(pam50 %in% c("Normal-like","HER2-enriched")), 
	which(is.na(st2)))
idx <- union(idx, which(is.na(pam50)))
pID <- colData(brca)$patientID
tokeep <- setdiff(pID, pID[idx])
brca <- brca[,tokeep,]

pam50 <- colData(brca)$PAM50.mRNA
colData(brca)$pam_mod <- pam50

smp <- sampleMap(brca)
samps <- smp[which(smp$assay=="BRCA_mRNAArray-20160128"),]
notdup <- samps[which(!duplicated(samps$primary)),"colname"]
brca[[1]] <- brca[[1]][,notdup]

```

The important thing is to create `ID` and `STATUS` columns in the sample metadata slot. netDx uses these to get the patient identifiers and labels, respectively.

```{r,eval=FALSE}
pID <- colData(brca)$patientID
colData(brca)$ID <- pID
colData(brca)$STATUS <- colData(brca)$pam_mod
```

# Rules to create features (patient similarity networks)

```{r,eval=FALSE}
groupList <- list()

# genes in mRNA data are grouped by pathways
pathList <- readPathways(fetchPathwayDefinitions("January",2018))
groupList[["BRCA_mRNAArray-20160128"]] <- pathList[1:3]
# clinical data is not grouped; each variable is its own feature
groupList[["clinical"]] <- list(
      age="patient.age_at_initial_pathologic_diagnosis",
	   stage="STAGE"
)
```

## Define patient similarity for each network

This is identical to the function used for binary classification.

```{r}
makeNets <- function(dataList, groupList, netDir,...) {
	netList <- c() # initialize before is.null() check
	# make RNA nets (NOTE: the check for is.null() is important!)
	# (Pearson correlation)
	if (!is.null(groupList[["BRCA_mRNAArray-20160128"]])) { 
	netList <- makePSN_NamedMatrix(dataList[["BRCA_mRNAArray-20160128"]],
				rownames(dataList[["BRCA_mRNAArray-20160128"]]),
			   	groupList[["BRCA_mRNAArray-20160128"]],
				netDir,verbose=FALSE, 
			  	writeProfiles=TRUE,...) 
	}
	
	# make clinical nets (normalized difference)
	netList2 <- c()
	if (!is.null(groupList[["clinical"]])) {
	netList2 <- makePSN_NamedMatrix(dataList$clinical, 
		rownames(dataList$clinical),
		groupList[["clinical"]],netDir,
		simMetric="custom",customFunc=normDiff, # custom function
		writeProfiles=FALSE,
		sparsify=TRUE,verbose=TRUE,...)
	}
	netList <- c(unlist(netList),unlist(netList2))
	return(netList)
}

```

# Build predictor

This call is also identical to that used for the binary classifier. 
 
```{r,eval=FALSE}
set.seed(42) # make results reproducible
outDir <- sprintf("%s/pred_output",tempdir()) # location for intermediate work
# set keepAllData to TRUE to not delete at the end of the predictor run.
# This can be useful for debugging.

out <- buildPredictor(dataList=brca,groupList=groupList,
  makeNetFunc=makeNets,outDir=outDir,
  numSplits=2L,featScoreMax=2L, featSelCutoff=1L,
	numCores=1L)
```

# Examine output
The results are stored in the list object returned by the `buildPredictor()` call.
This list contains:

* `inputNets`: all input networks that the model started with. 
* `Split<i>`: a list with results for each train-test split
  * `predictions`: real and predicted labels for test patients
  * `accuracy`: percent accuracy of predictions
  * `featureScores`: feature scores for each label (list with `g` entries, where `g` is number of patient labels). Each entry contains the feature selection scores for the corresponding label.
  * `featureSelected`: vector of features that pass feature selection. List of length `g`, with one entry per label.

```{r,eval=FALSE}
summary(out)
summary(out$Split1)
```

Save results to a file for downstream analysis:
```{r,eval=FALSE}
save(out,file=sprintf("%s/results.rda",outDir))
```

Write prediction results to text files. But also compute accuracy for three-way
classification.

```{r,eval=FALSE}
# Average accuracy
acc <- matrix(NA,ncol=length(st),nrow=numSplits) 
colnames(acc) <- st 

numSplits <- 2
st <- unique(colData(brca)$STATUS) # to get similarity scores for each class
for (k in 1:numSplits) { 
	pred <- out[[sprintf("Split%i",k)]][["predictions"]];
	oF <- sprintf("%s/Split%i_predictionResults.txt",outDir,k)
	tmp <- pred[,c("ID","STATUS","TT_STATUS","PRED_CLASS",sprintf("%s_SCORE",st))]
	write.table(tmp,file=oF,sep="\t",col=TRUE,row=FALSE,quote=FALSE)
}

print(round(acc,2))

print("Confusion matrix")
res <- out$Split1$predictions
print(table(res[,c("STATUS","PRED_CLASS")]))
```


```{r}
sessionInfo()
```
