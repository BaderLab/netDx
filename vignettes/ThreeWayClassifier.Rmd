---
title: "Build N-way classifier (N>2) from clinical and multi-omic data"
author: "Shraddha Pai"
package: netDx
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
    %\VignetteIndexEntry{02. Build three-way classifier (N-way; N>2) from multi-omic data}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---



# Introduction

In this example, we will use clinical data and three types of 'omic data - gene expression, DNA methylation and proteomic data - for binary classification of breast tumours. We also use several strategies and definitions of similarity to create features. 

 * Clinical variables: Each *variable* is its own feature (e.g. age); similarity is defined as *normalized difference*. 
 * Gene expression: Features are defined at the level of ***pathways***; i.e. a feature groups genes corresponding to the pathway. Similarity is defined as pairwise *Pearson correlation*
 * Proteomic and methylation data: Features are defined at the level of the entire *data layer*; a single feature is created for all of proteomic data, and the same for methylation. Similarity is defined by pairwise *Pearson correlation*

# Setup
Load the `netDx` package.

```{r,eval=TRUE}
suppressWarnings(suppressMessages(require(netDx)))
```

# Data 

For this example we pull data from the The Cancer Genome Atlas through the BioConductor `curatedTCGAData` package. The fetch command automatically brings in a `MultiAssayExperiment` object. 
```{r,eval=TRUE}
suppressMessages(library(curatedTCGAData))
```

We use the `curatedTCGAData()` command to look at available assays in the breast cancer dataset. 
```{r,eval=TRUE}
curatedTCGAData(diseaseCode="BRCA", assays="*",dry.run=TRUE,version="1.1.38")
```

In this call we fetch only the gene expression, proteomic and methylation data; setting `dry.run=FALSE` initiates the fetching of the data.

```{r,eval=TRUE}
brca <- suppressMessages(
   curatedTCGAData("BRCA",
               c("mRNAArray","RPPA*","Methylation_methyl27*"),
	dry.run=FALSE,version="1.1.38"))
```

This next code block prepares the TCGA data. In practice you would do this once, and save the data before running netDx, but we run it here to see an end-to-end example. 

```{r,eval=TRUE}
source("prepare_data.R")
brca <- prepareData(brca,setBinary=TRUE)
```

The important thing is to create `ID` and `STATUS` columns in the sample metadata slot. netDx uses these to get the patient identifiers and labels, respectively.

```{r,eval=TRUE}
pID <- colData(brca)$patientID
colData(brca)$ID <- pID
```

ADD HOLDOUT TEXT HERE
```{r}
set.seed(123)
dsets <- subsampleValidationData(brca,pctValidation=0.1)
brca <- dsets$trainMAE
holdout <- dsets$validationMAE
```

# Rules to create features (patient similarity networks)

Our plan is to group gene expression data by pathways and clinical data by single variables. We will treat methylation and proteomic data each as a single feature, so each of those groups will contain the entire input table for those corresponding data types. 

In the code below, we fetch pathway definitions for January 2018 from (http://download.baderlab.org/EM_Genesets) and group gene expression data by pathways. To keep the example short, we limit to only three pathways, but in practice you would use all pathways meeting a size criterion; e.g. those containing between 10 and 500 genes. 

Grouping rules are accordingly created for the clinical, methylation and proteomic data. 

```{r,eval=TRUE}
groupList <- list()

# genes in mRNA data are grouped by pathways
pathFile <- sprintf("%s/extdata/pathway_ex3.gmt", path.package("netDx"))
pathList <- readPathways(pathFile)
groupList[["BRCA_mRNAArray-20160128"]] <- pathList
# clinical data is not grouped; each variable is its own feature
groupList[["clinical"]] <- list(
      age="patient.age_at_initial_pathologic_diagnosis",
	   stage="STAGE"
)
# for methylation generate one feature containing all probes
# same for proteomics data
tmp <- list(rownames(experiments(brca)[[2]]));
names(tmp) <- names(brca)[2]
groupList[[names(brca)[2]]] <- tmp

tmp <- list(rownames(experiments(brca)[[3]]));
names(tmp) <- names(brca)[3]
groupList[[names(brca)[3]]] <- tmp
```

## Define patient similarity for each network

ADD SOME INTRO TEXT HERE

`normDiff` is a function provided in the `netDx` package, but the user may define custom similarity functions in this block of code and pass those to `makePSN_NamedMatrix()`, using the `customFunc` parameter.

```{r,eval=TRUE}
sims <- list(a="pearsonCorr",b="normDiff",c="pearsonCorr",d="pearsonCorr")
names(sims) <- names(groupList)
```

# Build predictor

Finally we make the call to build the predictor. 
 
```{r,eval=TRUE}
nco <- round(parallel::detectCores()*0.75) # use 75% available cores
message(sprintf("Using %i of %i cores", nco, parallel::detectCores()))

outDir <- paste(tempdir(),"pred_output",sep=getFileSep()) # use absolute path
if (file.exists(outDir)) unlink(outDir,recursive=TRUE)
numSplits <- 2L
t0 <- Sys.time()
model <- suppressMessages(
buildPredictor(
	dataList=brca,			## your data
	groupList=groupList,	## grouping strategy
	sims=sims,
	outDir=outDir, 			## output directory
	trainProp=0.8,			## pct of samples to use to train model in
							## each split
	numSplits=2L,			## number of train/test splits
 	featSelCutoff=1L,		## threshold for calling something
							## feature-selected
	featScoreMax=2L,		## max score for feature selection
 numCores=nco,			## set higher for parallelizing
 debugMode=FALSE,
 keepAllData=FALSE,	## set to TRUE for debugging or low-level files used by the dictor
 logging="none"
  ))
t1 <- Sys.time()
print(t1-t0)
```


```{r,eval=TRUE}
results <- getResults(model,unique(colData(brca)$STATUS),
	featureSelCutoff=2L,featureSelPct=0.50)
```

# Validate on independent samples
Now we use `predict()` to classify samples in the independent dataset. We provide the model with feature design rules in `groupList`, the list of selected features to use in `featSelNet`, the function to convert data into patient similarity networks in `makeNets`, as well as the original and validated datasets in `brca` and `holdout` respectively.

The training data needs to be provided because netDx creates a single patient similarity network with both training and test data. It then uses label propagation to "diffuse" patient labels from training samples to test samples, and labels the latter based on which class they are most similar to.

```{r,eval=TRUE}
outDir <- paste(tempdir(), randAlphanumString(), 
  sep = getFileSep())
if (file.exists(outDir)) unlink(outDir,recursive=TRUE)
dir.create(outDir)

predModel <- suppressMessages(
  predict(trainMAE=brca, testMAE=holdout, 
    groupList=groupList, 
    selectedFeatures=results$selectedFeatures, 
    sims=sims,
    outDir=outDir, verbose = FALSE)
)
```

# Plot results of validation

Finally we examine how well our model performed, using `getPerformance()`. 

Compute performance:
```{r,eval=TRUE}
perf <- getPerformance(predModel, 
  unique(colData(brca)$STATUS))

message(sprintf("AUROC=%1.2f*100", perf$auroc))
message(sprintf("AUPR=%1.2f*100", perf$aupr))
message(sprintf("Accuracy=%1.1f%%", perf$acc))
```

We plot the AUROC and AUPR curves using `plotPerf_multi()`.

```{r,eval=TRUE}
plotPerf_multi(list(perf$rocCurve),
  plotTitle = sprintf(
    "BRCA Validation: %i samples", 
    nrow(colData(holdout))))
plotPerf_multi(list(perf$prCurve), 
  plotType = "PR",
  plotTitle = sprintf(
    "BRCA Validation: %i samples", 
    nrow(colData(holdout))))

```

# sessionInfo
```{r,eval=TRUE}
sessionInfo()
```
